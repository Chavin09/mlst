#!/usr/bin/env perl
use strict;
use File::Spec;
use Data::Dumper;
use List::MoreUtils qw(pairwise);
use File::Temp qw(tempfile);
use FindBin;
use lib "$FindBin::Bin/../perl5";
use MLST::PubMLST;
use MLST::Scheme;
use MLST::Logger qw(err msg);
use MLST::Requirements qw(require_exe);
use MLST::FileUtils qw(is_genbank genbank_to_fasta is_gzipped gunzip_file);

#..............................................................................
# Globals

my $VERSION = "1.4-dev";
my $SEP = '/';
my $OUTSEP = "\t";

#..............................................................................
# Command line options

my(@Options, $verbose, $quiet, $blastdb, $datadir, $threads,
             $list, $longlist, $minid, $csv, $nopath);
setOptions();

#..............................................................................
# Option parsing

MLST::Logger->quiet($quiet);

$OUTSEP = ',' if $csv;  # default is tab

my $pubmlst = MLST::PubMLST->new( dir => $datadir );
my %scheme = (map { ($_->name => $_) } @{$pubmlst->schemes});

if ($list or $longlist) {
  if ($list) { 
    print join( " ", $pubmlst->names ), "\n";
  }
  elsif ($longlist) {
    for my $s (@{ $pubmlst->schemes }) {
      print join( $OUTSEP, $s->name, @{$s->genes} ), "\n";
    }
  }
  exit(0);
}

@ARGV or err("Please provide some FASTA files to determine the MLST of");

require_exe("blastn");

#..............................................................................
# Output results
 

for my $argv (@ARGV) 
{
  my @temp;
  my $infile = $argv;
  
  if ( is_gzipped($argv) ) {
    (undef,$infile) = tempfile(UNLINK=>1);
    msg("Decompressing: $argv'");
    gunzip_file($argv, $infile);
    push @temp, $infile;
  }
  if ( is_genbank($infile) ) {
    my $orig = $infile;
    (undef,$infile) = tempfile(UNLINK=>1);
    msg("Converting to FASTA: $argv");
    genbank_to_fasta($orig, $infile);
    push @temp, $infile;
  }

  msg("Scanning: $argv [$infile]");  
  my($scheme, $ST, $sig) = find_mlst($infile);
  my @gene = $scheme eq '-' ? () : @{ $scheme{$scheme}->genes };
  my @code = $scheme eq '-' ? () : split m{$SEP}, $sig ;
  my @allele = pairwise { "$a($b)" } @gene, @code;

  (undef,undef,$argv) = File::Spec->splitpath($argv) if $nopath;
  print join($OUTSEP, $argv, $scheme, $ST, @allele),"\n";
  if (@temp) {
    msg("Deleting temporary files: @temp");
    unlink @temp;
  }
}

#----------------------------------------------------------------------

sub find_mlst {
  my($fname) = @_;
  my $cmd = "blastn -query \Q$fname\E -db \Q$blastdb\E"
           ." -ungapped -dust no -evalue 1E-9 -num_threads $threads"
           ." -perc_identity $minid -outfmt '6 sseqid slen length nident'";
  msg("Running: $cmd") if $verbose;

  my @hit = qx($cmd);
  # FIXME: we should /sort/ the hits here in case logic below is dodgy
  
  my %res;
  foreach (@hit) {
    next unless m/ ^ (\w+)\.(\w+)[_-](\d+) \t (\d+) \t (\d+) \t (\d+) $ /x;
    my($scheme, $gene, $num, $hlen, $alen, $nident) = ($1, $2, $3, $4, $5, $6);
    next unless $nident/$hlen > $minid/100 ;
    msg("$scheme $gene $num | id=$nident/$alen | cov=$alen/$hlen") if $verbose;
    if ($hlen == $alen and $nident == $hlen) {   # need full length 100% hits
      if (exists $res{$scheme}{$gene} and $res{$scheme}{$gene} !~ m/~/) {
        msg("WARNING: found addtional exact allele match $scheme.$gene-$num");
        $res{$scheme}{$gene} .= ",$num";
      }
      else {
        $res{$scheme}{$gene} = "$num";
      }
    }
    else {
      $res{$scheme}{$gene} ||= "~$num";
    }
  }

  # find the signature with the fewest missing/approximate alleles  
  my @sig = ( [ '-', '-', join("/", ('-')x7) ] );  # sentinel
  for my $name (keys %res) {
    my $sig = $scheme{$name}->signature_of($res{$name});
    my $ST = $scheme{$name}->sequence_type($sig);
    push @sig, [ $name, $ST, $sig ];
  }
  @sig = sort { 
    ($a->[2] =~ tr/-~/-~/) <=> ($b->[2] =~ tr/-~/-~/)    # choose less missings
    or $a->[1] <=> $b->[1]   # if same, prefer scheme with 'older' number
  } @sig;
  print STDERR Dumper(@sig) if $verbose;
  # take the top scorer
  return @{ $sig[0] };
}

#----------------------------------------------------------------------

sub show_version {
  my(undef,undef,$exe) = File::Spec->splitpath($0);
  print "$exe $VERSION\n";
  exit(0);
}

#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"verbose!",  VAR=>\$verbose, DEFAULT=>0, DESC=>"Verbose output to"},
    {OPT=>"version!",  VAR=>\&show_version, DESC=>"Print version and exit"},
    {OPT=>"quiet!",  VAR=>\$quiet, DEFAULT=>0, DESC=>"Quiet - no stderr output"},
    {OPT=>"blastdb=s",  VAR=>\$blastdb, DEFAULT=>"$FindBin::RealBin/../db/blast/mlst.fa", DESC=>"BLAST database"},
    {OPT=>"datadir=s",  VAR=>\$datadir, DEFAULT=>"$FindBin::RealBin/../db/pubmlst", DESC=>"PubMLST data"},
    {OPT=>"list!",  VAR=>\$list, DEFAULT=>0, DESC=>"List available MLST scheme names"},
    {OPT=>"longlist!",  VAR=>\$longlist, DEFAULT=>0, DESC=>"List allelles for all MLST schemes"},
    {OPT=>"minid=f",  VAR=>\$minid, DEFAULT=>90, DESC=>"DNA %identity to consider 'similar'"},
    {OPT=>"threads=i",  VAR=>\$threads, DEFAULT=>1, DESC=>"Number of BLAST threads (suggest GNU Parallel instead)"},
    {OPT=>"csv!",  VAR=>\$csv, DEFAULT=>0, DESC=>"Output CSV instead of TSV"},
    {OPT=>"nopath!",  VAR=>\$nopath, DEFAULT=>0, DESC=>"Strip filename paths from FILE column"},
  );

  &GetOptions(map {$_->{OPT}, $_->{VAR}} @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

sub usage {
  print "Usage: $0 [options] <contigs.fa[.gz] | file.gbk[.gz]> ... \n";
  foreach (@Options) {
    printf "  --%-13s %s%s.\n",$_->{OPT},$_->{DESC},
           defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
  }
  exit(1);
}
 
#----------------------------------------------------------------------
