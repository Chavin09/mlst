#!/usr/bin/env perl

use warnings;
use strict;
use File::Temp qw(tempdir);
use File::Spec;
use Data::Dumper;
use FindBin;

#..............................................................................
# Globals

my $VERSION = "1.4-dev";

my $NONE = '-';
my $NOVEL = '~';
my $SEP = '/';
my $OUTSEP = "\t";

#..............................................................................
# Command line options

my(@Options, $verbose, $debug, $datadir, $minid,
             $list, $longlist, $scheme,  
             $noheader, $csv, $nopath);
setOptions();

#..............................................................................
# Option parsing

$OUTSEP = ',' if $csv;  # default is tab

# check if 'blat' installed
my($blat)=qx(blat 2> /dev/null);
$blat && $blat =~ m/blat/ or die "Could not run 'blat'. Please install it.";

# check if 'gzip' installed
my $zcat='gzip -d -c -f';
my($gzip)=qx(gzip --version 2>&1);
if (!$gzip or $gzip !~ m/gzip/) {
  print STDERR "WARNING: could not find 'gzip'. Compressed files can't be read. Pressing on.\n";
  $zcat='cat';  # if they don't have this things are really messed up!
}

my @sc = schemes();

if ($list) { 
  print join( " ", @sc ), "\n";
  exit(0);
}

if ($longlist) {
  for my $sc (@sc) {
    print join( $OUTSEP, $sc, scheme_alleles($sc) ), "\n";
  }
  exit(0);
}

$scheme or die "Please specify a --scheme. Use --list or --longlist to see available schemes.";

die "Invalid scheme: $scheme" unless ( grep { $_ eq $scheme } @sc );

die "Please provide some FASTA files to determine the MLST of" unless @ARGV;

#..............................................................................
# Load MLST data set

my $st = load_scheme($scheme) or die "Could not load MLST scheme: $scheme";
#print STDERR Dumper($st) if $verbose;

#..............................................................................
# Output results

print join($OUTSEP, "FILE", "SCHEME", "ST", @{$st->{GENES}}), "\n" unless $noheader;
for my $fname (@ARGV) {
  my($mlst,$sig) = find_mlst($st, $fname);
  if ($mlst) {
    my @allele = split m{$SEP}, $sig ;
    if ($nopath) {
      (undef,undef,$fname) = File::Spec->splitpath($fname);
    }
    print join($OUTSEP, $fname, $st->{SCHEME}, $mlst, @allele),"\n";
  }
}

#----------------------------------------------------------------------

sub find_mlst {
  my($st, $fname) = @_;

  -r $fname or die "can not open file: $fname";
  my $ref = $st->{TMPDIR}."/ref.fasta";  
  # force decompress to stdout
  print STDERR "Scanning: $fname\n";
  system("$zcat '$fname' > '$ref'"); 

  my $cmd = "blat '$st->{FASTA}' '$ref' -minIdentity=$minid -noTrimA /dev/stdout 2> /dev/null";
  print STDERR "Running: $cmd\n" if $verbose;
  open PSL, '-|', "$cmd | sort -k1nr";
   
#  my %best_frac = (map { ($_ => 0) } @{$st->{GENES}});
  my @hit;
  my %match;
  while (<PSL>) {
    # PSL format: http://asia.ensembl.org/info/website/upload/psl.html
    next unless m/^\d+/;
    chomp;
    my @x = split ' ';  # fields are SPACE separated?
    # 13 tName - Target sequence name
    $x[13] =~ m/^(.+?).(\d+)$/ or die "can't parse gene: $x[13]"; 
    my($g,$n) = ($1,$2);
    # 0  matches - Number of matching bases that aren't repeats.
    # 14 tSize - Target sequence size.
    my $frac = $x[0] / $x[14];
    my $symbol = $x[0]==$x[14] ? "$n" : "$NOVEL$n";
    push @hit, [ $g, $symbol, $frac ];
    print STDERR "### $g-$n $symbol $frac | @x\n" if $debug;
  }
  close PSL;
  
  # sort by $frac
  @hit = reverse sort { $a->[2] <=> $b->[2] } @hit;
  for my $hit (@hit) {
    $match{ $hit->[0] } ||= $hit->[1];  # keep best $frac
  }
  
  my $sig = join( '/', map { $match{$_} || $NONE } @{$st->{GENES}} );
  print STDERR "Determined MLST: $scheme | @{$st->{GENES}} | $sig\n";
  return ($st->{TYPE}{$sig} || $NONE, $sig);
}

#----------------------------------------------------------------------

sub schemes {
  # use special 'ls' options and syntax to only list DIRECTORIES
#  my @s = qx(ls -d $datadir/*/);
  my @s = qx(ls $datadir);
  chomp @s;
  return @s;
}

#----------------------------------------------------------------------

sub scheme_alleles {
  my($scheme) = @_;
  open TSV, '<', "$datadir/$scheme/$scheme.txt" or die "Corrupt scheme: $scheme";
  my $header = <TSV>;
  chomp $header;
  my @x = split m/\t/, $header;
  # remove non-allele columns
  while ($x[-1] =~ m/(complex|clade|species|lineage|^CC$)/i) {
    pop(@x);
  }
#  pop(@x) if $x[-1] =~ m/species/;
#  pop(@x) if $x[-1] =~ m/clonal_complex/;
  return @x[1 .. $#x];
}

#----------------------------------------------------------------------

sub load_scheme {
  my($scheme) = @_;
  my %st;
  $st{TMPDIR} = tempdir("mlst-XXXXXX", DIR=>=>File::Spec->tmpdir(), CLEANUP=>1);
  print STDERR "Temp dir: $st{TMPDIR}\n" if $verbose;
  $st{FASTA} = $st{TMPDIR}."/genes.fasta";
  $st{SCHEME} = $scheme;
  open TSV, '<', "$datadir/$scheme/$scheme.txt" or die "Corrupt scheme: $scheme";
  my @gene;
  while (<TSV>) {
    chomp;
    my @x = split m/\t/;
    if (@x < 2) {
      print STDERR "Skipping bad line: $_\n" if $verbose;
      next;
    }
    if ($. == 1) {
      @gene = grep { $_ !~ m/(^ST|complex|clade|species|lineage|^CC)/i  } @x;
      $st{GENES} = [ @gene ];
      print "Allelles: @gene\n" if $verbose;
    }
    else {
      my $sig = join( $SEP, @x[1..@gene] );
      $st{TYPE}{$sig} = $x[0];
    }
  }
  close TSV;
  
  for my $gene (@gene) {
    system("cat '$datadir/$scheme/$gene.tfa' >> '$st{FASTA}'");
  }
  printf STDERR "Sequence types: %d\n", scalar keys %{$st{TYPE}} if $verbose;
  return \%st;
}

#----------------------------------------------------------------------

sub version {
  print "$FindBin::RealScript $VERSION\n";
  exit;
}

#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"debug!",  VAR=>\$debug, DEFAULT=>0, DESC=>"Debugging output"},
    {OPT=>"verbose!",  VAR=>\$verbose, DEFAULT=>0, DESC=>"Verbose output"},
    {OPT=>"version!",  VAR=>\&version, DESC=>"Print version and exit"},
    {OPT=>"datadir=s",  VAR=>\$datadir, DEFAULT=>"$FindBin::RealBin/../db/pubmlst", DESC=>"Downloaded PubMLST data"},
    {OPT=>"list!",  VAR=>\$list, DEFAULT=>0, DESC=>"List available MLST scheme names"},
    {OPT=>"longlist!",  VAR=>\$longlist, DEFAULT=>0, DESC=>"List allelles for all MLST schemes"},
    {OPT=>"scheme=s",  VAR=>\$scheme, DEFAULT=>'', DESC=>"Use this typing scheme"},
    {OPT=>"noheader!",  VAR=>\$noheader, DEFAULT=>0, DESC=>"Suppress column header row"},
    {OPT=>"csv!",  VAR=>\$csv, DEFAULT=>0, DESC=>"Output CSV instead of TSV"},
    {OPT=>"minid=i",  VAR=>\$minid, DEFAULT=>95, DESC=>"Minumum identity to report as ? allele"},
    {OPT=>"nopath!",  VAR=>\$nopath, DEFAULT=>0, DESC=>"Strip filename paths from FILE column"},
  );

  &GetOptions(map {$_->{OPT}, $_->{VAR}} @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

sub usage {
  print "Usage: $0 [options] --scheme XXX <contigs.fasta> ... \n";
  foreach (@Options) {
    printf "  --%-13s %s%s.\n",$_->{OPT},$_->{DESC},
           defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
  }
  exit(1);
}
 
#----------------------------------------------------------------------

__DATA__

http://asia.ensembl.org/info/website/upload/psl.html
PSL File Format - Definition and supported options
Fields are space-separated, and all 21 are required.

 0  matches - Number of matching bases that aren't repeats.
 1 misMatches - Number of bases that don't match.
 2 repMatches - Number of matching bases that are part of repeats.
 3 nCount - Number of 'N' bases.
 4 qNumInsert - Number of inserts in query.
 5 qBaseInsert - Number of bases inserted into query.
 6 tNumInsert - Number of inserts in target.
 7 tBaseInsert - Number of bases inserted into target.
 8 strand - defined as + (forward) or - (reverse) for query strand.
 9 qName - Query sequence name.
10 qSize - Query sequence size.
11 qStart - Alignment start position in query.
12 qEnd - Alignment end position in query.
13 tName - Target sequence name.
14 tSize - Target sequence size.
15 tStart - Alignment start position in query.
16 tEnd - Alignment end position in query.
17 blockCount - Number of blocks in the alignment.
18 blockSizes - Comma-separated list of sizes of each block.
19 qStarts - Comma-separated list of start position of each block in query.
20 tStarts - Comma-separated list of start position of each block in target.
